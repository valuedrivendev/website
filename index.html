<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Value Driven Development (VDD)</title><link rel="stylesheet" href="css/bootstrap.min.css"><link rel="stylesheet" href="css/sticky-footer.css"><link rel="stylesheet" href="highlight/styles/vs.css"><style>body{font-family:Helvetica,Arial,serif;font-size:1.7em;line-height:1.8em}.footer{font-size:small}pre{background-color:transparent}code{color:#000;background-color:transparent}span.hlquote{border-radius:7px;padding:5px;background-color:#f0f0f0}</style><!--[if lt IE 9]><script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script><![endif]--></head><body><nav class="navbar navbar-default"><div class="container"><div class="navbar-header"><button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <a class="navbar-brand" href="/">Value Driven Development</a></div><div id="navbar" class="collapse navbar-collapse"><ul class="nav navbar-nav"><li id="navbar-home-button"><a href="/">Home</a></li><li id="navbar-about-button"><a href="/about.html">About</a></li><li><a href="https://github.com/valuedrivendev/website">GitHub</a></li></ul></div></div></nav><div class="container"><script>var navbar_active="#navbar-home-button";</script><h1><a href="#20150730" id="20150730">#</a> 0 to 1</h1><p>July 30, 2015.</p><p>A <a href="https://en.wikipedia.org/wiki/Flip-flop_%28electronics%29">flip-flop</a> is fundamental building block of a computer. A flip-flop can store an input signal &mdash; on or off &mdash; as a state and generate an output matching the stored input. This enables a binary number system by treating the "on" state as 1 and the "off" state as 0. A "bit" is 0 or 1. A flip-flop is suitable for storing one bit. Eight bits make a "byte." When a program asks a computer to change a bit, a byte containing the bit is retrieved, modified and stored on computer memory or a hard drive as a whole. A byte is the smallest unit of information.</p><p>Computer memory or <a href="https://en.wikipedia.org/wiki/Random-access_memory">random-access memory</a> (RAM) stores many gigabytes of information &mdash; a gigabyte has 1073741824 bits, not one billion bits. RAM is made of a grid of flip-flops connected by electrical paths. Changes to a byte require state transitions in eight flip-flops representing one unit of information. Nobody likes half baked bits, and flip-flop changes must be synchronized. A <a href="https://en.wikipedia.org/wiki/Crystal_oscillator">crystal oscillator</a> or "clock" is used to coordinate reading and writing information because a periodic pulse acts as a traffic light. When a clock generates a pulse, the traffic light says "go," and you are free to read or modify bytes. When a clock is in-between pulses, the traffic light says "stop and wait." We wait for pending operations to finish.</p><p>I flip bits when I press a key on my keyboard. I am a conductor for the mighty electrons if you will. I view computer programs in the same light &mdash; they flip bits. I often joke that a computer program is nothing more than a for-loop. A for-loop reads, "for every input specified, generate an appropriate output." Oversimplification? Perhaps.</p><p>The essence of a program is to generate an output given an input. Even a simple assignment is a flip-flop morphing function.</p><pre><code>int a = 1;
</code></pre><p>Just like that, I flipped bits in computer memory to reflect my thoughts. Writing the previous sentence is no different. My beloved <a href="http://www.vim.org"><code>vim</code></a> flips bits in memory, then the computer faithfully stores the bits on a hard drive. I am not the mastermind behind this. Some clever electrical, computer and system engineers; computer scientists and hackers have translated their soul into a big blob of transistors. This crazy world of mine, what would I do without this love?</p><p>I get a sense of control when I type away on a keyboard. Keys make pleasing sound. Letters on the screen fly by. But this well coordinated magic is beyond my skills and understanding. That is okay. They say some mystery keeps a loving relationship healthy. I will let my computers keep the blue smoke inside.</p><p>Can this explain my love for details in my technical work? I aim to understand inner workings of a computer at every level accessible to me. Sadly, I am not smart enough to understand them fully. I leave the true understanding of the machine to people far exceeding my intelligence. I watch from sidelines and take what I can so my undying love makes me warm and fuzzy.</p><hr><h1><a href="#20150721" id="20150721">#</a> Jumbo Patches</h1><p>July 21, 2015.</p><h3>My frustration</h3><p>was at the critical mass when I sent this email to the whole team. Juniors needed a reminder. The technical lead didn't get it. I told the boss about my frustrations. But nothing changed.</p><h3>Please stop writing jumbo patches.</h3><p>Not all jumbo patches are bad. But some are nasty. Nasty jumbo patches are by-products of source code heroics or refactoring and bug fixes. Refactoring is <em>damned</em> hard. It requires regression testing, domain expertise and care to avoid the trap of meaningless personal preferences. Add bug fixes on top of that.</p><p>How many senior developers would you like to sacrifice to review nasty jumbo patches?</p><h3>All patches should be atomic.</h3><p>That is, a patch should be the smallest coherent change set possible to address one issue. A reviewer should not be asked to distinguish between bug fixes, subtle changes in behaviours and code clean up. Why aren't they separate patches?</p><h3>A small patch is manageable.</h3><p>Reviewers and testers can focus on changes with the most value. A small patch localizes production issues due to a limited scope. A small patch invites reviewers with varying levels of technical skills and expertise. A small patch makes me happy.</p><h3>This is not just my opinion.</h3><p>Open source software has developed practical guidelines that scale to a large group of talented developers. The contribution guidelines in Linux provide great insights. GCC, Perl and Python share similar thoughts.</p><p><span class="hlquote">All emphasis are mine.</span></p><p><a href="https://www.kernel.org/doc/Documentation/SubmittingPatches">How to Get Your Change Into the Linux Kernel or Care And Operation Of Your Linus Torvalds</a></p><blockquote><p>Solve only <span class="hlquote">one problem per patch</span>. If your description starts to get long, that's a sign that you probably need to split up your patch.</p><p><span class="hlquote">Separate each <em>logical change</em> into a separate patch.</span></p></blockquote><p><a href="http://www.ozlabs.org/~akpm/stuff/tpp.txt">The perfect patch</a></p><blockquote><p>If your patch series includes <span class="hlquote">non-runtime-affecting things</span> such as cleanups, whitespace fixes, file renames, moving functions around, etc. then this work should be done in the <span class="hlquote">initial patches</span> in the series. The <span class="hlquote">functional changes</span> should come <span class="hlquote">later</span> in the series.</p></blockquote><p><a href="https://gcc.gnu.org/contribute.html">Contributing to GCC</a></p><blockquote><p><span class="hlquote">Don't mix together changes made for different reasons.</span> Send them individually. Ideally, <span class="hlquote">each change</span> you send should be <span class="hlquote">impossible to subdivide</span> into parts that we might want to consider separately, because each of its parts gets its motivation from the other parts. In particular, changes to <span class="hlquote">code formatting</span> to conform to coding standards are <span class="hlquote">best not mixed with substantive changes</span>, because that makes it difficult to see what the real changes are.</p></blockquote><p><a href="http://perldoc.perl.org/perlhack.html">perlhack</a></p><blockquote><p><em>Does it potentially introduce new bugs?</em></p><p>Radical <span class="hlquote">rewrites</span> of large chunks of the Perl interpreter have the <span class="hlquote">potential to introduce new bugs.</span></p><p><em>How big is it?</em></p><p>The <span class="hlquote">smaller</span> and more <span class="hlquote">localized</span> the change, the <span class="hlquote">better</span>. Similarly, a series of small patches is <span class="hlquote">greatly preferred</span> over a single large patch.</p><p><em>Does it create too much work?</em></p><p>Work for the pumpking, work for Perl programmers, work for module authors, ... Perl is <span class="hlquote">supposed to be easy.</span></p></blockquote><p><a href="https://docs.python.org/devguide/committing.html">Python Developer's Guide</a></p><blockquote><p>We usually prefer to put a whole feature or bugfix into a single commit, but no more. In particular:</p><ul><li><span class="hlquote">Do not fix more than one issue</span> in the same commit (except, of course, if one code change fixes all of them).</li><li><span class="hlquote">Do not do cosmetic changes to unrelated code</span> in the same commit as some feature/bugfix.</li></ul></blockquote><hr><h1><a href="#20150712" id="20150712">#</a> Source Code Documentation</h1><p>July 12, 2015.</p><p>I noticed a bug about a week ago in my code. The project had been on hold for about two months. I figured, "it is about time." To my surprise, diagnosing the problem took some effort despite the detailed documentation. Then I found the bug in a piece of poorly documented code. Go figure.</p><p>What about unit tests? I discuss unit tests at the end of this post.</p><h3>The Bug</h3><p>I wrote a function to replace a prefix of a path with another one.</p><pre><code>;; Re-anchor :name from a to b.
(defn replace-prefix
  [path a b]
  (clojure.string/replace path a b))
</code></pre><p>This was a quick hack for a prototype. Of course, I used the same excuse to skip tests. This function has a few bugs. Can you spot them?</p><p>The function seems simple in isolation, but the bug analysis expands the scope of work. Are there similar problems elsewhere? Should I refactor the code and create a well-tested utility function? It never ends. I told myself, "I wish I had left more context behind."</p><p>I would have found logic errors if I tried to explain this function to myself using examples. For instance, I may have added the following in documentation.</p><pre><code class="clojure">;; For example,
;;  (replace-prefix "/r/a" "/r/" "/R") => "/R/a"
;;  (replace-prefix "/r/a" "/r"  "/R") => "/R/a"
</code></pre><p>Claims made in examples do not reflect the implementation.</p><pre><code>(replace-prefix "/r/a" "/r/" "/R") =&gt; "/Ra"  ; Bad.
(replace-prefix "/r/a" "/r"  "/R") =&gt; "/R/a" ; Good.
</code></pre><p>A possible solution is shown below.</p><pre><code>(defn replace-prefix
  [path old-prefix new-prefix]
  (str new-prefix
       separator
       (clojure.string/replace path old-prefix "")))
</code></pre><p>This function is still incomplete because it does not address many cases.</p><ol><li>What happens when <code>old-prefix</code> is not a prefix of <code>path</code>?</li><li>What about repeated path separators? Does it matter?</li><li>And so on.</li></ol><h3>Examples, examples, examples!</h3><p>I love it when a programmer takes time and care to document illustrative examples in source code. User contributed examples seem very effective as well; see <a href="https://clojuredocs.org/clojure.core/map" title="clojure.core/map">clojure.core/map</a> for instance.</p><p>Listing all expected behaviours of a function exhaustively has no value because it leaves creating a concise summary to readers. On the other hand, providing a few representative examples is pragmatic but more difficult than the former. That does mean that we should skip it.</p><h3>What about unit tests?</h3><p>I like well-tested utility functions. They are even better when they come with documentation full of examples. A reliable and automated unit test suite may be a better solution than a list of input and output pairs. But don't you see? You need some possible input and output pairs to write tests!</p><hr><h1><a href="#20150630" id="20150630">#</a> I Love Documentation.</h1><p>June 30, 2015.</p><p>Yes, it is true. I love writing it. I love reading it. I enjoy clear and concise documentation. Why?</p><h3>A masterful display of an art</h3><p>is beautiful. I read <a href="http://www.paulgraham.com/onlisp.html">On Lisp</a> by <a href="http://www.paulgraham.com/">Paul Graham</a> for his writing.</p><p>My love for coding shares the same rationale.</p><h3>Learning requires repetition.</h3><p>Our <a href="https://en.wikipedia.org/wiki/Short-term_memory">short-term memory</a> is limited. Any information in short-term memory must be committed to <a href="https://en.wikipedia.org/wiki/Long-term_memory">long-term memory</a> for us to remember it. This is over-simplified but I hope you see the relevance of a small buffer with a long write latency.</p><p>Good documentation is valuable; write it well once.</p><h3>Flaw Discovery</h3><p>Describing a poorly designed system in different perspectives is hard. A high-level overview requires you to assume the role of an architect or a lead. Describing an example forces you to assume the role of a user.</p><p>I find it difficult to explain even a couple of modules clearly when their design is broken, not to mention varying perspectives.</p><hr><h1><a href="#20150624" id="20150624">#</a> Reading Code</h1><p>June 24, 2015.</p><p>I am reading <em>How to Write a Sentence: And How to Read One</em> by Stanley Fish. It is a great read. The consistent theme seems to be "learn the forms." That reminds me of how I read code.</p><h3>My Method</h3><ol><li><p>Identify the <strong>goal</strong> of a change.</p><p>"Catch the exception, E, and handle it."</p></li><li><p>Identify the <strong>operations</strong> required to implement the change.</p><p>There must be a new <tt>catch</tt> clause.</p></li><li><p>Find <strong>code</strong> that performs the required operations.</p><p>This should be obvious. Otherwise, the patch is too big.</p></li><li><p>Map the <strong>structure</strong> of the change bottom-up.</p><ol><li>What happens after the exception is handled?</li><li>Is the relevant code a part of a sequence? If so, how does the change fit in the sequence?</li><li>Is the exception handled at a correct location?</li></ol></li></ol><h3>"Structure" sounds like "form."</h3><p>I focus on learning the organization when I review code. It is like a jigsaw puzzle to me.</p><hr><h1><a href="#20150623" id="20150623">#</a> Code Review</h1><p>June 23, 2015.</p><p>We are terrible at code reviews. I think I contribute to the problem. I also have opinions about them. I <strong>do not</strong> recommend using this style of code review for training people.</p><h3>I think a code review is</h3><p>an invitation to read a finished work. It is matters of opinion whether code is "good" or "bad". Sometimes, the competing solutions to a problem are equally acceptable. By the same token, a style is a part of a presented work to admire.</p><h3>If you take a step back,</h3><p>code reviews become more pleasant. You avoid the temptation to correct the other person. You check that the presented work is complete, acceptable and correct.</p><p>I do not mean "agree to disagree." I ask you to find ways to improve the presented work. What would you suggest in the <strong>same</strong> approach and style to improve the code?</p><h3>Of course, there are dangers.</h3><p>Maybe, it is absolutely horrible code. It must be re-written! Well, then maybe, a second opinion is required. Maybe, it is okay.</p><hr><h1><a href="#20150622" id="20150622">#</a> Class Constructors</h1><p>June 22, 2015.</p><p>I recently decided to make a rule about default parameters in C# or any similar objected oriented language. Why? I found it useful for my work! :-)</p><h3>Where do we specify default values for class constructor parameters?</h3><p>I apologize for indentation and omitting access modifiers. Here is an example in C#.</p><pre><code>class History {
  // A list of old values.
  IList&lt;long&gt; m_values;

  // Initialize with pre-loaded data
  // or no history.
  History(IList&lt;long&gt; v = null) {
    // m_values = v ?? new IList&lt;long&gt;();
    if (v == null) {
      m_values = new IList&lt;long&gt;();
    } else {
      m_values = v;
    }
  }
}

class HistoryFactory {
  Create(IList&lt;long&gt; v = null) {
    return new History(v);
  }
}
</code></pre><p>Constructors should assume that its dependencies are correctly initialized when object creation has been delegated to a framework like a factory or dependency injection. For example, I think this works better.</p><pre><code>class History {
  // A list of old values.
  IList&lt;long&gt; m_values;

  // Initialize with pre-loaded data
  // or no history.
  History(IList&lt;long&gt; v) {
    m_values = v;
  }
}

class HistoryFactory {
  Create(IList&lt;long&gt; v = null) {
    var h = v ?? new IList&lt;long&gt;();
    return new History(h);
  }
}
</code></pre><h3>Default values are configuration data.</h3><p>I think this separates data and code. When default values change, the core logic stays the same.</p><p>While it is common to create new objects in constructors like ours, I delegate that to a factory. This allows me to create an object with a long history for testing while providing a way to reload history from external resources.</p><hr><h1><a href="#20150615" id="20150615">#</a> Simple Stuff</h1><p>June 15, 2015.</p><p>The website source code is available at <a href="http://github.com/valuedrivendev/website">GitHub</a>. The bare and tediously written HTML may surprise you.</p><p>I feel great about it. I am focusing on the content, not the appearance of the website. The appearance will become important. That is for later.</p><p>I believe I am making the right choice. If you agree with me, then I must thank my sources of free advice.</p><p><em>Value</em> does not always mean money. For example, I hope you enjoy reading simple sentences on a small screen. This post is, perhaps, short enough.</p><hr><h1><a href="#20150611" id="20150611">#</a> Mentorship at Work</h1><p>June 11, 2015.</p><p>I have a great manager at work. I am grateful for that. All the co-workers are great too, well, except one. That is for another day.</p><h3>I love being a mentor.</h3><p>You may find this rather odd if you knew me personally. Well, then again, I am a bit preachy. Look at this website! So, yes, mentorship, I truly find it so gratifying.</p><h3>Huh, what now?</h3><p>I love growing influence over people. The fact that I can persuade somebody amuses me. It is even better if everyone repeats back what I say. It starts with little expressions to a common ideal the team shares. So I try my hand at influencing others.</p><p>Of course, that is not all. When I watch people improve their strategies to debug or solve problems over time, it is like watching plants grow.</p><p>The key phrase at work now is, <strong>"Is there any value in doing this work?"</strong> I did pretty well there!</p><h3>I am aggressive at times.</h3><p>That is not for people I mentor. When I am aggressive, I am really saying, <strong>"Wake up, you can do better,"</strong> because I respect and trust you enough to "do the right thing."</p><hr><h1><a href="#20150606" id="20150606">#</a> Refactoring - Decompose Conditional</h1><p>June 06, 2015.</p><p>I recently bought the book, <i>Refactoring - Improving the Design of Existing Code</i>. I enjoy reading it a lot.</p><h3>I am not a fanatic</h3><p>when it comes to these topics anymore. I use what produces the most value. The example below illustrates the idea. Please do not take this literally. Sometimes, refactoring tiny code has no value.</p><h3>An example in Java</h3><p>Before</p><pre><code>if (min &lt;= x &amp;&amp; x &lt;= max) {
    y = x / 2;
} else {
    y = x * x;
}
</code></pre><p>After</p><pre><code>if (inRange(min, max, x)) {
    y = half(x);
} else {
    y = square(x);
}

private boolean inRange(
    int start,
    int end,
    int x) {
    return (start &lt;= x &amp;&amp; x &lt;= end);
}

private int half(int n) {
    return n / 2;
}

private int square(int n) {
    return n * n;
}
</code></pre><h3>I use this the most in Clojure projects.</h3><p>Maybe, that is because I am not so fluent in Clojure yet. The same method seems to be more valuable in Clojure even for tiny functions. Nested s-expressions become very confusing quickly.</p><p>Before</p><pre><code>(let [y (if (and (&lt;= min x) (&lt;= x max))
          (x / 2)
          (x * x))]
  ...)
</code></pre><p>After</p><pre><code>(let [y (calculate-y min max x)]
  ...)

(defn calculate-y [min max x]
  (if (in-range? min max x)
    (half x)
    (square x)))

(defn in-range? [start end x]
  (and (&lt;= start x) (&lt;= x end)))

(defn half [x]
  (/ x 2))

(defn square [x]
  (* x x))
</code></pre><hr><h1><a href="#20150603" id="20150603">#</a> Building Autonomy</h1><p>June 03, 2015.</p><p>If a developer can train two new hires at the same time, then the best case result is having three developers who can train new hires. These three developers are probably enough to sustain the training process.</p><h3><tt>3 x 2 = 6 - 4 = 2</tt></h3><p>When there are three trainers, each trainer can train two new hires. This gives us six newly trained developers. Even if the entire trainer team quits, we can recover by holding onto two or more developers.</p><h3><tt>T1 &lt;- T2 &lt;- ... &lt;- Tn</tt></h3><p>Perhaps, this is too naive. How about this? We introduce a simple linear process. Every hire will always train newer employees. If the mentor does not have an answer to a problem, then we visit the next mentor in the chain. This leaves the most experience developers to handle the most difficult problems.</p><p>Experienced developers are expensive and incredibly productive. They should not be disturbed and be left to their art where the most value is.</p><hr><h1><a href="#20150528" id="20150528">#</a> Value Driven Development</h1><p>May 28, 2015.</p><p><em>Value Driven Development</em> or VDD emphasizes improving life of <strong>maintaining legacy code without tests</strong>. The suggestions here do not apply to all situations. I would recommend these suggestions for bugs you can fix and test under an hour.</p><p><strong>Prefer small bug fixes. Avoid writing tests and refactoring until they are absolutely required.</strong></p><h3>Working with legacy code is what we do mostly.</h3><p>When faced with modifying legacy code, most people start with writing tests. That might involve refactoring code first to make it testable. This may take weeks if you are not careful. This is not productive.</p><h3>That is not lost productivity.</h3><p>Right; "the code is more maintainable," "the code is more readable" and etc.</p><p>Well, ugly or not, <strong>legacy code has been around</strong>. In other words, it has been tested in the real world. If it is a one-off bug, then what are chances that you will have to come back to it again? Not all situations work out well. We will talk about that later. If a particular area is troublesome, then you must consider other ways to resolve that. VDD is not suitable for these cases.</p><h3>Think of it this way.</h3><p>This insanity perfectly pleases capitalistic minds. <strong>Source code is a business</strong>. You may argue that it is a business asset -- that is fine. <strong>Every bug is an investment opportunity</strong> because fixing it will increase the business value -- yes, pun intended. The best return from an investment depends on gaining more value than any resource invested; for example, time or salary. It makes sense to minimize the work required to address a problem.</p><h3>Okay, what are you cutting out from this business?</h3><p>Small fixes are easier to verify manually than large refactoring changes thanks to (a) scopes of change; and (b) minimal chances of regression. <strong>Fix bug without writing tests first</strong>. Please test fixes locally to avoid wasting code review and testing time. <strong>Problems found in code reviews or testing indicate the need to write tests.</strong> Then, go write some tests.</p><h3>What if problems persist in the same area?</h3><p>Then, I guess it is time for a heavy-duty refactoring/clean-up axe.</p></div><footer class="footer text-muted"><div class="container"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="img/cc-license.png"></a> <span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">valuedrivendev.com</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="http://valuedrivendev.com" property="cc:attributionName" rel="cc:attributionURL">Brian Jung Myeng Lee</a> is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">(link)</a>.</div></footer><script src="js/jquery.min.js"></script><script src="js/bootstrap.min.js"></script><script src="highlight/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>function lazy_load_css(e){var t=function(){var t=document.createElement("link");t.rel="stylesheet",t.href=e;var n=document.getElementsByTagName("head")[0];n.parentNode.insertBefore(t,n)},n=requestAnimationFrame||mozRequestAnimationFrame||webkitRequestAnimationFrame||msRequestAnimationFrame;n?n(t):window.addEventListener("load",t)}</script><script>$(document).ready(function(){$(navbar_active).addClass("active")});</script></body></html>